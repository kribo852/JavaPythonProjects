<!DOCTYPE html>
<html>
<body>


<canvas id="myCanvas" width="1600" height="400"></canvas>

<br>
<input type="button" value="1" onclick="steer(0)"></input>
<input type="button" value="2" onclick="steer(1)"></input>
<input type="button" value="3" onclick="steer(2)"></input>
<input type="button" value="4" onclick="steer(3)"></input>
<br>
<img id="myImg" src="http://images.duckduckgo.com/iu/?u=http%3A%2F%2F2paragraphs.com%2Fwp-content%2Fuploads%2F2014%2F03%2Flenna.jpg&f=1" style="display: none;"/>
<img id="myImg1" src="http://2.bp.blogspot.com/_Tv9hZO-X8Gk/TROBnpPLzYI/AAAAAAAAFe4/3hWnumGJ9Rg/s1600/Ginko-Tree-12.jpg" style="display: none;"/>
<img id="myImg2" src="http://i.4cdn.org/wg/1508516922663.jpg" style="display: none;"/>
<img id="myImg3" src="http://i.4cdn.org/wg/1508258190045.jpg" style="display: none;"/>
<img id="myImg4" src="sav.png" style="display: none;"/>
<img id="myImg5" src="blob120.png" style="display: none;"/>
<img id="myImg6" src="http://2.bp.blogspot.com/-ENu1z-tOm5M/TxdgxTByXXI/AAAAAAAAAOk/woABLTlwYxs/s1600/sunset1.jpg" style="display: none;"/>
<img id="myImg7" src="https://upload.wikimedia.org/wikipedia/commons/d/d1/Karst_HaLongBay_Vietnam_%28pixinn.net%29.jpg" style="display: none;"/>

<script>

map=new Array();
mapSize=25;

for(i = 0; i < mapSize; i++){
	map[i]=new Array();
	for(j = 0; j < mapSize; j++){ 
		if(Math.random()>0.67){
			map[i][j]=Math.floor((Math.random() * 7) + 1);
		}else{
			map[i][j]=0;
		}
	}
}

x=10.5;
y=10.5;
while(map[parseInt(x)][parseInt(y)]!=0){
	x=Math.floor((Math.random() * mapSize))+0.5;
	y=Math.floor((Math.random() * mapSize))+0.5;	
}
angle=0;
scale=25;
xoffset=750;
redrawMap();
redrawPlayer();
rayCast();
function steer(direction){
	if(direction==0){
		angle+=0.25;
	}
	if(direction==1){
		angle-=0.25;
	}
	
	if(direction==2){
		if(!isWall(x+0.1*Math.sin(angle), y)){
			x+=0.1*Math.sin(angle);
		}
		if(!isWall(x, y+0.1*Math.cos(angle))){
			y+=0.1*Math.cos(angle);
		}
	}
	if(direction==3){
		if(!isWall(x-0.1*Math.sin(angle), y)){
			x-=0.1*Math.sin(angle);
		}
		if(!isWall(x, y-0.1*Math.cos(angle))){
			y-=0.1*Math.cos(angle);
		}
	}
	redrawPlayer();	
	rayCast();
}

function redrawMap() {
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");
	ctx.restore();
		
	for(i = 0; i < 25; i++)for(j = 0; j < 25; j++){
		if(map[i][j]==0){
			 ctx.fillStyle = "#FFFFFF";
		}else{
			ctx.fillStyle = "#FFA000";
		}
		ctx.fillRect(xoffset+i*scale,j*scale,scale,scale);
	}
}

function redrawPlayer(){
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");
	ctx.restore();
	
	for(i = -1; i < 2; i++)for(j = -1; j < 2; j++){
		repaintx=i+parseInt(x);
		repainty=j+parseInt(y);
		if(repaintx>=0 && repainty>=0 && repaintx<mapSize && repainty<mapSize) {
			if(map[repaintx][repainty]==0){
				ctx.fillStyle = "#FFFFFF";
			}else{
				ctx.fillStyle = "#FFA000";
			}
		}
		ctx.fillRect(xoffset+repaintx*scale ,repainty*scale ,scale , scale);
	}
	ctx.beginPath();
	ctx.moveTo(x*scale+xoffset, y*scale);
	ctx.lineTo(x*scale+xoffset+scale*Math.cos(Math.PI/2-angle-0.5), y*scale+scale*Math.sin(Math.PI/2-angle-0.5));
	ctx.stroke();
	ctx.moveTo(x*scale+xoffset, y*scale);
	ctx.lineTo(x*scale+xoffset+scale*Math.cos(Math.PI/2-angle+0.5), y*scale+scale*Math.sin(Math.PI/2-angle+0.5));
	ctx.stroke();

}

function paintSky(ctx, xlen, ylen){
	var grd = ctx.createLinearGradient(0,0,0,250);
	grd.addColorStop(1,"#FFAF00");
	grd.addColorStop(0,"#2580A0");
	ctx.fillStyle = grd;
	ctx.fillRect(0,0,xlen,ylen);
}

function rayCast(){
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");
	
	ctx.restore();
	paintSky(ctx, 750, 200)
	ctx.fillStyle = "#BFCFC8";
	ctx.fillRect(0,200,750,400);
	
	var anglediff=Math.PI/200.0;
	
	for(i=-50; i<50; i++) {
		current=angle+anglediff*(i-100);
		sinlen=-Math.sin(current);
		coslen=Math.cos(current);
		
		range=closestWall(sinlen, coslen);
		if(range>0) {
			paintStripe(range, sinlen, coslen, 50+i);
		}
	}	
}

function closestWall(sinlen, coslen){
	var magnitude=0.01;
	for(range=magnitude; range<8 ; range+=magnitude){
		if(magnitude<0.5){//bättre precision på nära håll
			magnitude*=1.05;// försämra precisionen
			if(isWall(x+range*coslen, y+range*sinlen)) {
				for(minirange=0; minirange<=magnitude; minirange+=0.005){//hitta mer exakt väggposition
					if(isWall(x+(range-magnitude+minirange)*coslen, y+(range-magnitude+minirange)*sinlen)) {
						return (range-magnitude+minirange);
					}
				}
			}
		}
		if(isWall(x+(range)*coslen, y+(range)*sinlen)) {
			return range;
		}	
		
	}
	return -1;
}

function paintStripe(range, sinlen, coslen, screenx){
	var xpos=x+range*coslen;
	var ypos=y+range*sinlen;
	var position=0;
	var midy=200;
	var image;
	var squarex=parseInt(xpos);
	var squarey=parseInt(ypos);
	if(squarex<0 || squarex>=mapSize || squarey<0 || squarey>=mapSize){
		image = document.getElementById("myImg");
	}else{
		image = document.getElementById("myImg"+map[squarex][squarey]);
	}
	
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");
	
	xpos++;//since these variables only used for modulo and there seems to be a problem with modulo negative numbers
	ypos++;
	
	if(Math.abs((xpos%1)-0.5)<Math.abs((ypos%1)-0.5)){
		if((ypos%1)<0.5) {
			position=xpos%1;
		} else {
			position=1-xpos%1;
		}
	}else{
		if((xpos%1)>0.5) {
			position=ypos%1;
		} else {
			position=1-ypos%1;
		}
	}
	var rangecofficient=100;
	var rangeoffset=10;
	ctx.drawImage(image, position*image.width, 0, 3, image.height, screenx*7.5, midy-rangeoffset-rangecofficient/range, 15, 2*rangeoffset+2*rangecofficient/range);
}
function isWall(x, y){
	var squarex=parseInt(x);
	var squarey=parseInt(y);
	return (squarex<0 || squarex>=mapSize || squarey<0 || squarey>=mapSize || map[squarex][squarey]!=0);
}
</script>
</body>
</html>
